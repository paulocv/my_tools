"""
Template of a python script for scientific computation.
Features:
-  Accepts parameters from a YAML file (input_file)
-  Command-line arguments, which can override parameters from the file
-  Usage help with `--help` argument
-  Defines a folder for storing the outputs

The script defines two main containers: `Params` and `Data`
`Params` holds externally sourced parameters, like file paths, program
options, etc.
`Data` holds internal variables and data structures, like
pandas data frames or numpy arrays read from files, intermediate
objects, output structures, etc.

This script can also be easily called from another python script without
running a subprocess/call. For this, you can create the `Params` and `Data`
instances in your external script and call `main(params, data, argv)`.

Requirements: `pyyaml` for reading the input file (https://pypi.org/project/PyYAML/)
"""
import argparse
from pathlib import Path
import yaml  # Requires: PyYaml


# -------------------------------------------------------------------
# PROGRAM STRUCTURES
# -------------------------------------------------------------------

class Params:
    """All parameters. Include hardcoded script params, those read
    from inputs, and overriden by command line flags.

    Parameters will have type hints in PyCharm, but raise
    AttributeError if referenced before assignment.

    This class works more as an autocomplete guide. It will receive
    any parameter that is either defined here, at the input
    file or command line arguments.
    """
    input_file: Path
    output_dir: Path

    # Example parameter with no default value. This only creates a type
    # hint, helpful for autocompletion.
    param_no_default: int  # Typed

    # ...

    def __init__(self):
        # Example parameter with default value. Can be overridden by
        # a same-named parameter in the input file or command line.
        self.param_with_default: list = list()

    def preprocess(self):
        """This function is called once after the parameters were read
        from the input file.
        """
        # Example: converts path strings to pathlib.Path objects
        for param in ["input_file", "output_dir"]:
            setattr(self, param, Path(getattr(self, param)))


class Data:
    """This class should hold data that is created during the execution
    of the program, but not directly informed in the main input file.
    """
    # Example data structure with no default
    my_list: list
    # my_series: pd.Series  # pd.Series, np.ndarray, list, etc...
    # ...


# -------------------------------------------------------------------
# MAIN FUNCTION DEFINITION
# -------------------------------------------------------------------


def main(params: Params, data: Data, argv: list[str] = None):
    # Parse command line arguments
    args = get_arg_parser().parse_args(argv)
    # args: CLArgs = get_arg_parser().parse_known_args(argv)
    #               ^ ^ Use this to accept extra unknown arguments.

    # Import from input file
    import_and_preprocess_params(args, params, data)

    # Main operations
    # (check imported parameters. You can erase the line below)
    print(f"Your parameters are: \n{params.__dict__}")

    # ... [[PUT YOUR CODE HERE]]


# -------------------------------------------------------------------
# PROGRAM PROCEDURES
# -------------------------------------------------------------------

def get_arg_parser() -> argparse.ArgumentParser:
    """Interprets and stores the command line arguments."""

    parser = argparse.ArgumentParser(
        # usage="[[COMMAND LINE SIGNATURE (autogenerated)[]",
        description="Add here a description to show on --help calls.",
        # epilog="[[TEXT DISPLAYED AFTER ARGUMENTS DESCRIPTION]]",
    )

    # --- Positional paths
    parser.add_argument(
        "input_file", type=Path,
        help="Path to the file with input parameters."
    )
    parser.add_argument(
        "output_dir", type=Path,
        help="Path to the output directory, where all "
             "output files are stored."
    )

    # --- Optional flags
    parser.add_argument(  # Example. Retrieve as `optional_arg`
        "--optional-arg", type=str,
        help="Example of optional argument. Default value on `Params`. ",
    )

    return parser


def import_and_preprocess_params(args, params: Params, data: Data):
    """Imports the main YAML parameter file."""
    # --- Read file
    with open(args.input_file, "r") as fp:
        input_dict = yaml.load(fp, yaml.Loader)

    # --- Select command line arguments that are not `None`
    valid_args_dict = {
        key: val for key, val in args.__dict__.items() if val is not None
    }

    # --- Populate the Params in priority order
    # Script Default < Input File < Command Line Arguments
    params.__dict__.update(input_dict)
    params.__dict__.update(valid_args_dict)

    # data.input_dict = input_dict  # Use this to keep the input_dict

    # --- Preprocessing
    params.preprocess()


# ======================================================================


if __name__ == "__main__":
    main_params = Params()
    main_data = Data()
    main(main_params, main_data)
